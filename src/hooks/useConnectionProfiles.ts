import { useState, useEffect, useCallback } from 'react';
import { 
  ConnectionProfile, 
  CreateConnectionProfileRequest,
  ProfileSearchFilters,
  ProfileSortOptions,
  Environment
} from '@/types/database';
import { ConnectionProfileService } from '@/services/connection-profile-service';

interface UseConnectionProfilesReturn {
  profiles: ConnectionProfile[];
  loading: boolean;
  error: string | null;
  createProfile: (profile: CreateConnectionProfileRequest) => Promise<void>;
  updateProfile: (id: string, updates: Partial<ConnectionProfile>) => Promise<void>;
  deleteProfile: (id: string) => Promise<void>;
  connectToProfile: (id: string) => Promise<void>;
  refreshProfiles: () => Promise<void>;
  searchProfiles: (filters?: ProfileSearchFilters, sortOptions?: ProfileSortOptions) => Promise<void>;
}

export function useConnectionProfiles(): UseConnectionProfilesReturn {
  const [profiles, setProfiles] = useState<ConnectionProfile[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refreshProfiles = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const loadedProfiles = await ConnectionProfileService.getAllProfiles();
      setProfiles(loadedProfiles);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load profiles';
      setError(errorMessage);
      console.error('Failed to load profiles:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  const createProfile = useCallback(async (profileData: CreateConnectionProfileRequest) => {
    try {
      setError(null);
      
      // Create a temporary profile object for the service
      const tempProfile: ConnectionProfile = {
        id: '', // Will be generated by the service
        name: profileData.name,
        description: profileData.description,
        tags: profileData.tags || [],
        folder: profileData.folder,
        config: profileData.config,
        metadata: {
          isFavorite: false,
          autoConnect: false,
          environment: profileData.metadata?.environment || Environment.Development,
          monitoringEnabled: false,
          ...profileData.metadata,
        },
        createdAt: new Date(),
        updatedAt: new Date(),
        lastUsed: undefined,
        useCount: 0,
      };

      const createdProfile = await ConnectionProfileService.createProfile(tempProfile);
      setProfiles(prev => [...prev, createdProfile]);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create profile';
      setError(errorMessage);
      throw err;
    }
  }, []);

  const updateProfile = useCallback(async (id: string, updates: Partial<ConnectionProfile>) => {
    try {
      setError(null);
      const existingProfile = profiles.find(p => p.id === id);
      if (!existingProfile) {
        throw new Error('Profile not found');
      }

      const updatedProfile = {
        ...existingProfile,
        ...updates,
        updatedAt: new Date(),
      };

      const savedProfile = await ConnectionProfileService.updateProfile(id, updatedProfile);
      setProfiles(prev => prev.map(p => p.id === id ? savedProfile : p));
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update profile';
      setError(errorMessage);
      throw err;
    }
  }, [profiles]);

  const deleteProfile = useCallback(async (id: string) => {
    try {
      setError(null);
      await ConnectionProfileService.deleteProfile(id);
      setProfiles(prev => prev.filter(p => p.id !== id));
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to delete profile';
      setError(errorMessage);
      throw err;
    }
  }, []);

  const connectToProfile = useCallback(async (id: string) => {
    try {
      setError(null);
      
      // Mark profile as used
      await ConnectionProfileService.markProfileUsed(id);
      
      // Update the profile in our local state
      setProfiles(prev => prev.map(p => 
        p.id === id 
          ? { 
              ...p, 
              lastUsed: new Date(), 
              useCount: p.useCount + 1 
            }
          : p
      ));

      // TODO: Implement actual connection logic
      // This would typically involve:
      // 1. Retrieving credentials from the credential vault
      // 2. Establishing the database connection
      // 3. Updating the application's connection state
      console.log('Connecting to profile:', id);
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to connect to profile';
      setError(errorMessage);
      throw err;
    }
  }, []);

  const searchProfiles = useCallback(async (
    filters?: ProfileSearchFilters, 
    sortOptions?: ProfileSortOptions
  ) => {
    try {
      setLoading(true);
      setError(null);
      const searchResults = await ConnectionProfileService.searchProfiles(filters, sortOptions);
      setProfiles(searchResults);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to search profiles';
      setError(errorMessage);
      console.error('Failed to search profiles:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  // Initialize profiles on mount
  useEffect(() => {
    refreshProfiles();
  }, [refreshProfiles]);

  return {
    profiles,
    loading,
    error,
    createProfile,
    updateProfile,
    deleteProfile,
    connectToProfile,
    refreshProfiles,
    searchProfiles,
  };
}